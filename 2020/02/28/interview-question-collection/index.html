<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>


























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"/>

<link rel="stylesheet" href="/blog/css/main.css?v=7.0.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp;amp; why ?123var new_array = arr.map(function callback(currentValue[,index[, array]]) &amp;#123;// Return element for new_array&amp;#125;[, thisArg]) map方法需要传入一个函数作为参数，这">
<meta property="og:type" content="article">
<meta property="og:title" content="interview-question-collection">
<meta property="og:url" content="https://joyce-yunjiaoguo.github.io/blog/2020/02/28/interview-question-collection/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp;amp; why ?123var new_array = arr.map(function callback(currentValue[,index[, array]]) &amp;#123;// Return element for new_array&amp;#125;[, thisArg]) map方法需要传入一个函数作为参数，这">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190211141424731.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://user-images.githubusercontent.com/18718461/53536375-228ba180-3b41-11e9-9737-d71f85040cfc.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/20290821/53854366-2ec1a400-4004-11e9-8c62-5a1dd91b8a5b.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3174701-8e74b69ad9376710?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp">
<meta property="og:updated_time" content="2020-03-09T16:49:54.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="interview-question-collection">
<meta name="twitter:description" content="2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp;amp; why ?123var new_array = arr.map(function callback(currentValue[,index[, array]]) &amp;#123;// Return element for new_array&amp;#125;[, thisArg]) map方法需要传入一个函数作为参数，这">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190211141424731.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70">






  <link rel="canonical" href="https://joyce-yunjiaoguo.github.io/blog/2020/02/28/interview-question-collection/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>interview-question-collection | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br/>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://joyce-yunjiaoguo.github.io/blog/blog/2020/02/28/interview-question-collection/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JOYCE"/>
      <meta itemprop="description" content="Do what you want!"/>
      <meta itemprop="image" content="/blog/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">interview-question-collection

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-28 14:33:27" itemprop="dateCreated datePublished" datetime="2020-02-28T14:33:27+08:00">2020-02-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-10 00:49:54" itemprop="dateModified" datetime="2020-03-10T00:49:54+08:00">2020-03-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><a href="#2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why" class="headerlink" title="2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?"></a>2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[, array]]</span>) </span>&#123;</span><br><span class="line"><span class="comment">// Return element for new_array</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>
<p>map方法需要传入一个函数作为参数，这个函数有3个参数，currentValue, index 和 array。<br>所以实际执行的代码是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>对于parseInt(string[, radix])来说，目的是把string以radix作为基底，转为十进制整数。</p>
<p>string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。<br>radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。<br>返回值 返回一个整数或NaN</p>
<p>如果radix不在[2, 36]范围内，则返回NaN<br>如果radix没传值，js会做如下处理：<br>-如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).<br>-如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。es5规定按10，但现实不统一。<br>-如果字符串 string 以其它任何值开头，则基数是10 (十进制)。</p>
<p>所以执行如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN, 3 不是二进制</span></span><br></pre></td></tr></table></figure></p>
<p>最终返回[1, NaN, NaN]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果现实中，需要把数组中的字符串转为数字，怎么办呢？</span></span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// [10, NaN, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以采用如下方法：</span></span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10, 10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure>
<h1 id="4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h1><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>成员唯一、无序且不重复<br>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）<br>可以遍历，方法有：add、delete、has</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>成员都是对象<br>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏<br>不能遍历，方法有add、delete、has</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>本质上是键值对的集合，类似集合<br>可以遍历，方法很多可以跟各种数据格式转换</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>只接受对象作为键名（null除外），不接受其他类型的值作为键名<br>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的<br>不能遍历，方法有get、set、has、delete</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakSet运用场景</span></span><br><span class="line"><span class="comment">// 保证了Foo的实例方法，只能在Foo的实例上调用。</span></span><br><span class="line"><span class="comment">// 这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。</span></span><br><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">    method () &#123;</span><br><span class="line">        <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap运用场景1</span></span><br><span class="line"><span class="comment">// myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。</span></span><br><span class="line"><span class="comment">// 我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</span></span><br><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line">myElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap运用场景2</span></span><br><span class="line"><span class="comment">// ountdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</span></span><br><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(counter, action) &#123;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.set(<span class="keyword">this</span>, action);</span><br><span class="line">&#125;</span><br><span class="line">dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">    _action.get(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br></pre></td></tr></table></figure>
<h1 id="5-介绍下深度优先遍历和广度优先遍历，如何实现？"><a href="#5-介绍下深度优先遍历和广度优先遍历，如何实现？" class="headerlink" title="5. 介绍下深度优先遍历和广度优先遍历，如何实现？"></a>5. 介绍下深度优先遍历和广度优先遍历，如何实现？</h1><p>以遍历dom树为例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"1-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"1-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"1-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"2-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"2-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"2-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"3-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"3-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"3-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'parent'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 递归实现</span></span><br><span class="line"><span class="keyword">let</span> depthTraversal1 = <span class="function">(<span class="params">node, result = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        result.push(node);</span><br><span class="line">        <span class="keyword">let</span> children = node.children;</span><br><span class="line">        <span class="built_in">Array</span>.prototype.slice.call(children, <span class="number">0</span>).forEach(<span class="function"><span class="params">ele</span> =&gt;</span> depthTraversal1(ele, result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 利用栈先进后出</span></span><br><span class="line"><span class="keyword">let</span> depthTraversal2 = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> item = stack.pop();</span><br><span class="line">            <span class="keyword">let</span> children = item.children;</span><br><span class="line">            <span class="comment">// 注意：这里遍历children时需要逆序</span></span><br><span class="line">            <span class="built_in">Array</span>.prototype.slice.call(children, <span class="number">0</span>).reverse().forEach(<span class="function"><span class="params">ele</span> =&gt;</span> stack.push(ele));</span><br><span class="line">            result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS 利用队列先进先出</span></span><br><span class="line"><span class="keyword">let</span> widthTraversal = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        queue.push(node);</span><br><span class="line">        <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> item = queue.shift();</span><br><span class="line">            <span class="keyword">let</span> children = item.children;</span><br><span class="line">            <span class="built_in">Array</span>.prototype.slice.call(children, <span class="number">0</span>).forEach(<span class="function"><span class="params">ele</span> =&gt;</span> queue.push(ele));</span><br><span class="line">            result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-请分别用深度优先思想和广度优先思想实现一个拷贝函数？"><a href="#6-请分别用深度优先思想和广度优先思想实现一个拷贝函数？" class="headerlink" title="6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数？"></a>6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是对象/数组，返回一个空的对象/数组，</span></span><br><span class="line"><span class="comment">// 都不是的话直接返回原对象</span></span><br><span class="line"><span class="comment">// 判断返回的对象和原有对象是否相同就可以知道是否需要继续深拷贝</span></span><br><span class="line"><span class="comment">// 处理其他的数据类型的话就在这里加判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEmpty</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Object]'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">'[object Array]'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyBFS</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 记录出现过的对象，用于处理环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = getEmpty(origin);</span><br><span class="line">    <span class="keyword">if</span>(target !== origin)&#123;</span><br><span class="line">        queue.push([origin, target]);</span><br><span class="line">        map.set(origin, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> [ori, tar] = queue.shift();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> ori)&#123;</span><br><span class="line">            <span class="comment">// 处理环状</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(ori[key]))&#123;</span><br><span class="line">                tar[key] = map.get(ori[key]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tar[key] = getEmpty(ori[key]);</span><br><span class="line">            <span class="keyword">if</span>(tar[key] !== ori[key])&#123;</span><br><span class="line">                queue.push([ori[key], tar[key]]);</span><br><span class="line">                map.set(ori[key], tar[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyDFS</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 记录出现过的对象，用于处理环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = getEmpty(origin);</span><br><span class="line">    <span class="keyword">if</span>(target !== origin)&#123;</span><br><span class="line">        stack.push([origin, target]);</span><br><span class="line">        map.set(origin, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> [ori, tar] = stack.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> ori)&#123;</span><br><span class="line">            <span class="comment">// 处理环状</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(ori[key]))&#123;</span><br><span class="line">                tar[key] = map.get(ori[key]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tar[key] = getEmpty(ori[key]);</span><br><span class="line">            <span class="keyword">if</span>(tar[key] !== ori[key])&#123;</span><br><span class="line">                stack.push([ori[key], tar[key]]);</span><br><span class="line">                map.set(ori[key], tar[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// [deepCopyBFS, deepCopyDFS].forEach(deepCopy=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     console.log(deepCopy(&#123;a:1&#125;));</span></span><br><span class="line"><span class="comment">//     console.log(deepCopy([1,2,&#123;a:[3,4]&#125;]))</span></span><br><span class="line"><span class="comment">//     console.log(deepCopy(function()&#123;return 1;&#125;))</span></span><br><span class="line"><span class="comment">//     console.log(deepCopy(&#123;</span></span><br><span class="line"><span class="comment">//         x:function()&#123;</span></span><br><span class="line"><span class="comment">//             return "x";</span></span><br><span class="line"><span class="comment">//         &#125;,</span></span><br><span class="line"><span class="comment">//         val:3,</span></span><br><span class="line"><span class="comment">//         arr: [</span></span><br><span class="line"><span class="comment">//             1,</span></span><br><span class="line"><span class="comment">//             &#123;test:1&#125;</span></span><br><span class="line"><span class="comment">//         ]</span></span><br><span class="line"><span class="comment">//     &#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     let circle = &#123;&#125;;</span></span><br><span class="line"><span class="comment">//     circle.child = circle;</span></span><br><span class="line"><span class="comment">//     console.log(deepCopy(circle));</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>
<h1 id="7-ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#7-ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="7. ES5/ES6 的继承除了写法以外还有什么区别？"></a>7. ES5/ES6 的继承除了写法以外还有什么区别？</h1><h1 id="8-setTimeout、Promise、Async-Await-的区别"><a href="#8-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="8. setTimeout、Promise、Async/Await 的区别"></a>8. setTimeout、Promise、Async/Await 的区别</h1><h1 id="9-Async-Await-如何通过同步的方式实现异步"><a href="#9-Async-Await-如何通过同步的方式实现异步" class="headerlink" title="9. Async/Await 如何通过同步的方式实现异步"></a>9. Async/Await 如何通过同步的方式实现异步</h1><p>首先，async/await 是 Generator 的语法糖，先来看一下二者的对比：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">'../data/a.json'</span>), &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">yield</span> readFile(path.resolve(__dirname, <span class="string">'../data/b.json'</span>), &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">'../data/a.json'</span>), &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res1);</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(path.resolve(__dirname, <span class="string">'../data/b.json'</span>), &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = readFile();</span><br></pre></td></tr></table></figure></p>
<p>可以看到，async function 代替了 function*，await 代替了 yield，同时也无需自己手写一个自动执行器 run 了</p>
<p>现在再来看看async/await 的特点：</p>
<p>当 await 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行<br>执行 const res = readFile(); 返回的仍然是个 Promise 对象，上面代码中的 return ‘done’; 会直接被下面 then 函数接收到<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// done</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="10-js事件循环（event-loop）-amp-amp-异步"><a href="#10-js事件循环（event-loop）-amp-amp-异步" class="headerlink" title="10. js事件循环（event loop）&amp;&amp; 异步"></a>10. js事件循环（event loop）&amp;&amp; 异步</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我记得头条一面问过这种，主要考察的是事件循环中函数执行顺序的问题，其中包括async ，await，setTimeout，Promise函数。</p>
<p>先梳理一些概念：<br>事件循环eventloop：每进行一次循环操作称为 tick，每次循环会看任务队列里是否有待执行的任务，有的话就拿进来执行。<br>任务队列：JS分为同步任务和异步任务，同步任务都在主线程上执行，形成一个执行栈。异步任务会将其回调根据不同的任务源放入不同的任务队列中。</p>
<p>任务队列中分为宏任务和微任务，且有着优先级：<br>宏任务：script(同步代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)<br>微任务：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p>
<p>事件循环执行顺序：script -&gt; 所有微任务 -&gt; 渲染页面 -&gt; 一个宏任务 -&gt; 所有微任务</p>
<p>Promise中的代码是同步的，立即执行；then中才是异步的，会被放到微任务中；<br>async await中，await之前的代码都是同步的，立即执行；await之后的表达式先执行，之后的代码会被放到微任务中。</p>
<p>由于因为async await 本身就是promise+generator的语法糖。所以await后面的代码是microtask。所以对于本题中的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相当于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把await这样改写后，我觉得好理解多了，做题的时候也顺多了。</p>
<p>变式一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//async2做出如下更改：</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise4'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise4</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure></p>
<p>变式二：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//更改如下：</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout3'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout3</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br></pre></td></tr></table></figure></p>
<p>变式三：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">sync <span class="function"><span class="keyword">function</span> <span class="title">a1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> a2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">a1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'promise2.then'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// a1 start</span></span><br><span class="line"><span class="comment">// a2</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// a1 end</span></span><br><span class="line"><span class="comment">// promise2.then</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure></p>
<p>总结： 无论几层嵌套，遇到setTimeout就把里面的放进宏任务，遇到Promise就把then里面的放进微任务。</p>
<h1 id="11-数组扁平化，去重，升序"><a href="#11-数组扁平化，去重，升序" class="headerlink" title="11. 数组扁平化，去重，升序"></a>11. 数组扁平化，去重，升序</h1><p>已知如下数组：<br>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p>
<p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组。</p>
<p>-扁平化：arr.flat(depth) 按depth深度遍历递归数组，把所有元素放进新数组返回; depth默认为1，可以填Infinity<br>-去重： Set<br>-升序： arr.sort((a, b) =&gt; a -b)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写flat，不考虑depth，默认Infinity</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    arr.map(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(ele))&#123;</span><br><span class="line">            res = res.concat(flat(ele));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.push(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="12-JS-异步解决方案的发展历程以及优缺点。"><a href="#12-JS-异步解决方案的发展历程以及优缺点。" class="headerlink" title="12. JS 异步解决方案的发展历程以及优缺点。"></a>12. JS 异步解决方案的发展历程以及优缺点。</h1><pre><code>1. 回调函数
缺点： 回调地狱
2. Promise
优点： 解决了回调地狱的问题
缺点： 无法取消promise，错误需要通过回调函数来捕获
3. generator
4. async/await
</code></pre><h1 id="13-Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#13-Promise构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="13. Promise构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>13. Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</h1><p>构造器之内的同步；then里的异步执行，会放入微任务，等待上一个宏任务执行完再执行。<br>看看 promise 的源码实现！</p>
<h1 id="14-如何实现一个-new"><a href="#14-如何实现一个-new" class="headerlink" title="14. 如何实现一个 new"></a>14. 如何实现一个 new</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个空的对象，obj.__proto__ = fn.prototype</span></span><br><span class="line"><span class="comment">// 把上面创建的空对象赋值构造函数内部的this，执行构造函数，添加属性和方法</span></span><br><span class="line"><span class="comment">// 如果构造函数返回一个引用值，则返回这个值，否则返回上面创建的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">const</span> ret = fn.apply(obj, arg);</span><br><span class="line">    <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数是可以自己返回对象的</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.d = d;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    a: <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A(<span class="number">123</span>));  <span class="comment">//&#123;a: 6&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="15-简单讲解一下-http2-的多路复用"><a href="#15-简单讲解一下-http2-的多路复用" class="headerlink" title="15. 简单讲解一下 http2 的多路复用"></a>15. 简单讲解一下 http2 的多路复用</h1><p>HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</p>
<p>1、HTTP/1.0 版本<br>该版本主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。为了解决这个问题，需要使用 Connection: keep-alive 这个字段。</p>
<p>2、HTTP/1.1 版本<br>该版本引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。<br>还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>
<p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p>
<p>http2的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。</p>
<h1 id="18-React-中-setState-什么时候是同步的，什么时候是异步的？"><a href="#18-React-中-setState-什么时候是同步的，什么时候是异步的？" class="headerlink" title="18. React 中 setState 什么时候是同步的，什么时候是异步的？"></a>18. React 中 setState 什么时候是同步的，什么时候是异步的？</h1><h2 id="setState-队列机制"><a href="#setState-队列机制" class="headerlink" title="setState 队列机制"></a>setState 队列机制</h2><p>setState 通过一个<strong>队列机制</strong>来实现 state 更新，当执行 setState() 时，会将需要更新的 state 浅合并后放入 状态队列，而不会立即更新 state，队列机制可以高效的<strong>批量更新</strong> state。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 state.count === 0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// state.count === 1, 而不是 3</span></span><br></pre></td></tr></table></figure></p>
<p>而如果不通过setState，直接修改this.state 的值，则不会放入状态队列，当下一次调用 setState 对状态队列进行合并时，之前对 this.state 的修改将会被忽略。</p>
<p>为了避免因批量处理导致有些操作被合并，所以一般用 setState() 的第二种形式：以一个函数而不是对象作为参数，此函数的第一个参数是前一刻的state，第二个参数是 state 更新执行瞬间的 props。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    count: prevState.count + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
<p>工作机制类似于reducer。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">increment</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">increment</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">increment</span>: <span class="number">1</span>&#125;</span><br><span class="line">].reduce(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    count: prevState.count + props.increment</span><br><span class="line">&#125;), &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="setState-循环调用风险"><a href="#setState-循环调用风险" class="headerlink" title="setState 循环调用风险"></a>setState 循环调用风险</h2><p>如果在 shouldComponentUpdate 或 componentWillUpdate 方法里调用 this.setState 方法，就会造成循环调用，导致崩溃。</p>
<p>这是因为在 shouldComponentUpdate 或 componentWillUpdate 方法里调用 this.setState 时，this._pendingStateQueue!=null，则 performUpdateIfNecessary 方法就会调用 updateComponent 方法进行组件更新，而 updateComponent 方法又会调用 shouldComponentUpdate和componentWillUpdate 方法，因此造成循环调用，使得浏览器内存占满后崩溃。</p>
<p>根据源码，setState更新队列和shouldComponentUpdate都会导致updateComponent执行，updateComponenet中又会调用shouldComponentUpdate。。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将新的 state 合并到状态队列</span></span><br><span class="line"><span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据更新队列和 shouldComponentUpdate 的状态来判断是否需要更新组件</span></span><br><span class="line"><span class="keyword">var</span> shouldUpdate = <span class="keyword">this</span>._pendingForceUpdate ||</span><br><span class="line">    !inst.shouldComponentUpdate ||</span><br><span class="line">    inst.shouldComponentUpdate(nextProps, nextState, nextContext)</span><br></pre></td></tr></table></figure></p>
<h3 id="batchingStrategy"><a href="#batchingStrategy" class="headerlink" title="batchingStrategy"></a>batchingStrategy</h3><p><img src="https://img-blog.csdnimg.cn/20190211141424731.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1bmFoYWlqaWFv,size_16,color_FFFFFF,t_70" alt="setState简化调用栈"><br>通过 enqueueUpdate 来执行 state 更新时，如果batchingStrategy.isBatchingUpdates为false，会执行batchedUpdates，遍历所有的dirtyComponents，调用updateComponent，更新pending state or props；如果batchingStrategy.isBatchingUpdates为true，会丢进dirtyComponents中，等待执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">        batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> batchingStrategy = &#123;</span><br><span class="line">    isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        batchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>isBatchingUpdates默认为false，但当React在调用事件处理函数之前就会调用batchedUpdates，把isBatchingUpdates变为true，所以会走dirtyComponents，异步更新。</p>
<p>所以，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。</p>
<p>可以很好解释#19。</p>
<h1 id="19-React-setState-笔试题，下面的代码输出什么？"><a href="#19-React-setState-笔试题，下面的代码输出什么？" class="headerlink" title="19. React setState 笔试题，下面的代码输出什么？"></a>19. React setState 笔试题，下面的代码输出什么？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            val: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);    <span class="comment">// 第 1 次 log</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);    <span class="comment">// 第 2 次 log</span></span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);  <span class="comment">// 第 3 次 log</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);  <span class="comment">// 第 4 次 log</span></span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 0 2 3</span></span><br></pre></td></tr></table></figure>
<h1 id="20-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#20-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="20. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>20. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h1><p>-发出npm install 指定模块<br>-查询node_modules目录之中是否已经存在指定模块<br>    若存在，不再重新安装<br>    若不存在<br>        -npm 向 registry 查询模块压缩包的网址<br>        -下载压缩包，存放在根目录下的.npm目录里<br>        -解压压缩包到当前项目的node_modules目录</p>
<p>-npm install<br>-执行工程自身的preinstall<br>-确定首层依赖(dependencies, devDependencies中模块)，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点<br>-递归获取模块，确定模块版本-获取模块实体-是否有依赖-获取依赖模块。。。树结构<br>    npm3增加dedupe过程，它会遍历所有节点，逐个将模块放在也就是 node-modules 的第一层下。当发现有重复模块时，则将其丢弃。<br>    （如果同名且有兼容版本，则提出来放在node_modules下，否则保留在依赖树中）<br>-安装模块，更新node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。<br>-当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。<br>-生成或更新版本描述文件</p>
<h1 id="21-判断数组的三种方法，比较"><a href="#21-判断数组的三种方法，比较" class="headerlink" title="21. 判断数组的三种方法，比较"></a>21. 判断数组的三种方法，比较</h1><h2 id="Object-prototype-toString-call-arr-‘-Object-Array-’"><a href="#Object-prototype-toString-call-arr-‘-Object-Array-’" class="headerlink" title="Object.prototype.toString.call(arr) === ‘[Object Array]’"></a>Object.prototype.toString.call(arr) === ‘[Object Array]’</h2><pre><code>每一个继承 Object 的对象都有toString方法，除了对象类型，其他都会直接转成字符串返回。
对于对象类型，会返回[Object type]。
所以可以借用call/apply，Object.prototype.toString.call(a)得出a的类型，包括null和undefined。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'An'</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)) <span class="comment">// "[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">'An'</span>&#125;) <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure>
<p>-：如果Symbol.toStringTag被重写，判断不准确</p>
<h2 id="arr-instanceof-Array"><a href="#arr-instanceof-Array" class="headerlink" title="arr instanceof Array"></a>arr instanceof Array</h2><pre><code>判断对象的原型链中是不是能找到类型的prototype。
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> rightProto = rightVaule.prototype; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">    leftVaule = leftVaule.__proto__; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">    <span class="keyword">while</span> (leftVaule) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule = leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-： 1.只能判断引用值，原始值无法判断，instanceof右边必须是一个对象<br>    2.所有引用值instanceof Object都为true，因为所有引用值类型的构造函数都是继承自Object<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<pre><code>3.原型链可以修改，所以会不准确
</code></pre><h2 id="arr-constructor-Array"><a href="#arr-constructor-Array" class="headerlink" title="arr.constructor === Array"></a>arr.constructor === Array</h2><p>-: 1. null和undefined无法判断</p>
<ol start="2">
<li>函数的 constructor 是不稳定的，当开发者重写 prototype 后，原有的 constructor 引用会丢失<h2 id="Array-isArray-arr"><a href="#Array-isArray-arr" class="headerlink" title="Array.isArray(arr)"></a>Array.isArray(arr)</h2>Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。polyfill<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="22-重排（回流）-amp-重绘"><a href="#22-重排（回流）-amp-重绘" class="headerlink" title="22. 重排（回流）&amp;重绘"></a>22. 重排（回流）&amp;重绘</h1><p>浏览器会把HTML解析成DOM tree，把CSS解析成CSS tree，合并就产生了渲染树（Render Tree）；<br>流式布局遍历render tree，计算每个节点的位置和大小，渲染在页面上。</p>
<p>重排： 布局或者元素的几何属性改变，会引起重排<br>重绘： 元素的样式属性发生改变，不影响布局，会引起重绘</p>
<p><strong>重排一定会发生重绘；重绘不一定会发生重排。</strong></p>
<p>浏览器把会引起重排&amp;重绘的操作放进队列中，批量更新，一般16s刷新一次，清空队列。<br>但有一些操作会强制清空队列，影响性能：<br>-offsetTop、offsetLeft、offsetWidth、offsetHeight<br>-scrollTop、scrollLeft、scrollWidth、scrollHeight<br>-clientTop、clientLeft、clientWidth、clientHeight<br>-width、height<br>-getComputedStyle()<br>-getBoundingClientRect()</p>
<h2 id="如何减少重排重绘"><a href="#如何减少重排重绘" class="headerlink" title="如何减少重排重绘"></a>如何减少重排重绘</h2><h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><pre><code>- 不要使用table布局，小改动可能影响到全局；
- css3硬件加速（transform），性能更好
- 使用visibility代替display: none，visibility仅引起重绘
</code></pre><h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><pre><code>- 集中操作，可以把需要改变的样式统一写在class上，动态添加class即可
- documentFragment
- display: absolute；脱离文档流，操作完再放回文档流
- 需要多次获取的值，用变量存起来
</code></pre><h1 id="23-观察者模式和订阅-发布模式的区别"><a href="#23-观察者模式和订阅-发布模式的区别" class="headerlink" title="23. 观察者模式和订阅-发布模式的区别"></a>23. 观察者模式和订阅-发布模式的区别</h1><p><img src="https://user-images.githubusercontent.com/18718461/53536375-228ba180-3b41-11e9-9737-d71f85040cfc.png" alt="区别"></p>
<p>-在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。<br> 然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p>
<p>-在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。<br>-观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。<br>-观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="keyword">var</span> subject = &#123;</span><br><span class="line">    observers: [],</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span>&#123;</span><br><span class="line">            observer.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    attach (observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    update()&#123;</span><br><span class="line">        alert(<span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">subject.attach(observer)</span><br><span class="line">subject.notify()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅-发布模式</span></span><br><span class="line"><span class="keyword">var</span> publisher = &#123;</span><br><span class="line">    publish(pubsub) &#123;</span><br><span class="line">        pubsub.publish()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pubsub = &#123;</span><br><span class="line">    subscribes: [],</span><br><span class="line">    publish() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subscribes.forEach(<span class="function"><span class="params">subscribe</span> =&gt;</span>&#123;</span><br><span class="line">            subscribe.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    subscribe(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subscribes.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subscribe = &#123;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'update'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">        subscribe(pubsub) &#123;</span><br><span class="line">            pubsub.subscribe(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">subscribe.subscribe(pubsub)</span><br><span class="line">publisher.publish(pubsub)</span><br></pre></td></tr></table></figure>
<h1 id="24-Redux-和-Vuex-的设计思想"><a href="#24-Redux-和-Vuex-的设计思想" class="headerlink" title="24. Redux 和 Vuex 的设计思想"></a>24. Redux 和 Vuex 的设计思想</h1><h1 id="26-介绍模块化发展历程"><a href="#26-介绍模块化发展历程" class="headerlink" title="26. 介绍模块化发展历程"></a>26. 介绍模块化发展历程</h1><p>在模块化之前，一个文件引入多个js文件，需要考虑同名变量、文件依赖关系，非常不便。<br>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。<br>-立即执行函数 <strong>特点：在一个单独的函数作用域中执行代码，避免变量冲突。</strong><br>-AMD 使用requireJS来编写模块化 <strong>特点：依赖必须提前声明好。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'./index.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>-CMD 使用seaJS来编写模块化 <strong>特点：支持动态引入依赖文件。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">'./index.js'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>-ES Modules： ES6 引入的模块化，支持import 来引入另一个 js 。import a from ‘a’;<br>-CommonJS： nodejs 中自带的模块化。 var fs = require(‘fs’);</p>
<h1 id="27-全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？。"><a href="#27-全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？。" class="headerlink" title="27. 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。"></a>27. 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。</h1><p>ES5中，全局变量会挂在window上，可以通过window.xxx获取；<br>ES6中，如果用window.xxx获取用const和let声明的变量，会得到undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.aa); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.bb); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-images.githubusercontent.com/20290821/53854366-2ec1a400-4004-11e9-8c62-5a1dd91b8a5b.png" alt="浏览器控制台"><br>在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中。</p>
<p>在其声明的块级作用域中， 直接获取即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bb = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bb); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>let&amp;const 与 var 的区别：</p>
<ol>
<li>块级作用域 vs 函数作用域</li>
<li>不存在变量声明提升 vs 变量声明提升 (let&amp;const需要先声明再使用)</li>
<li>不允许重复声明变量 vs 重复声明变量</li>
<li>全局对象在其块级作用域中 vs 全局变量挂在window上，可以用window.xxx获取</li>
</ol>
<h1 id="28-cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><a href="#28-cookie-和-token-都存放在-header-中，为什么不会劫持-token？" class="headerlink" title="28. cookie 和 token 都存放在 header 中，为什么不会劫持 token？"></a>28. cookie 和 token 都存放在 header 中，为什么不会劫持 token？</h1><p>token主要是为了防御csrf攻击，因为同浏览器下cookie会被自动携带。</p>
<p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。减轻服务器的压力，减少频繁的查询数据库。</p>
<h1 id="29-Vue的双向数据绑定-MVVM"><a href="#29-Vue的双向数据绑定-MVVM" class="headerlink" title="29. Vue的双向数据绑定 MVVM"></a>29. Vue的双向数据绑定 MVVM</h1><ol>
<li>view -&gt; model<br>事件监听用户操作，改变data</li>
<li>model -&gt; view<br>数据劫持 + 订阅发布模式<br>Object.defineProperty的setter&amp;getter，一旦数据改变，触发setter，执行update</li>
</ol>
<p>observer 订阅<br>dev<br>watcher 发布</p>
<h1 id="30-请把俩个数组-A1-A2-B1-B2-C1-C2-D1-D2-和-A-B-C-D-，合并为-A1-A2-A-B1-B2-B-C1-C2-C-D1-D2-D-。"><a href="#30-请把俩个数组-A1-A2-B1-B2-C1-C2-D1-D2-和-A-B-C-D-，合并为-A1-A2-A-B1-B2-B-C1-C2-C-D1-D2-D-。" class="headerlink" title="30. 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。"></a>30. 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。</h1><h1 id="33"><a href="#33" class="headerlink" title="33."></a>33.</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>立即执行函数中的函数 是 函数表达式，函数表达式无法赋值，类似于const声明。<br>在strict模式下，给b赋值，会报错。<br>不在strict模式下，b = 20; 赋值无效，所以console.log(b)，输出对应函数。</p>
<h1 id="34"><a href="#34" class="headerlink" title="34."></a>34.</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 10</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h1 id="35-浏览器缓存读取机制"><a href="#35-浏览器缓存读取机制" class="headerlink" title="35. 浏览器缓存读取机制"></a>35. 浏览器缓存读取机制</h1><p><img src="https://upload-images.jianshu.io/upload_images/3174701-8e74b69ad9376710?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="浏览器缓存机制-脑图"></p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>Service Worker<br>Memory Cache<br>Disk Cache<br>Push Cache<br>按此顺序逐个查找缓存，如果没有命中则去下一个查找。</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>运行在浏览器背后的独立线程，与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过<strong>拦截请求</strong>的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。（拦截请求，必须使用HTTPS来保证安全）</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。<br>但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。<br>常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效 (为了给其他 TAB 腾出位置)。<br>而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。</p>
<p>memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 <code>&lt;img&gt;</code>，两个 href 相同的 <code>&lt;link&gt;</code>)都实际只会被请求最多一次，避免浪费。不过在匹配缓存时，除了匹配完全相同的 URL 之外，还会比对他们的类型，CORS 中的域名规则等。因此一个作为脚本 (script) 类型被缓存的资源是不能用在图片 (image) 类型的请求中的，即便他们 src 相等。</p>
<p>preloader<br>preload</p>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>存储在硬盘中的缓存，胜在容量和存储时效性上，读取速度比memory cache较慢。<br>根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。(缓存机制（强缓存&amp;协商缓存）)<br>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，并非严格执行HTTP头中的缓存指令。</p>
<h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p><img src="https://upload-images.jianshu.io/upload_images/3174701-9d9e8b52a18ed35a?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp" alt="缓存机制流程图"><br>强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。</p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>主要关注是否过期，但服务器端资源有可能更新过<br>-Expires<br> HTTP1.0，用来指定资源到期的时间，是服务器端的具体的时间点。</p>
<p>-Cache-Control HTTP1.1，优先级高于Expires<br> public 所有内容都将被缓存（客户端和代理服务器都可缓存）<br> private 默认值，所有内容只有客户端可以缓存<br> no-cache 是否使用缓存需要经过协商缓存来验证决定<br> no-store 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存<br> max-age max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效<br> s-maxage 同max-age作用一样，只在代理服务器中生效，优先级高于max-age<br> max-stale 能容忍的最大过期时间<br> min-fresh 能够容忍的最小新鲜度</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p> 判断服务器端资源是否更新，更新过则重新请求200，否则去缓存304<br>-Etag &amp; If-none-match 优先级较高，更准确，但速度慢需要计算，性能较差<br>    Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。<br>    第一次请求时，服务器返回资源及其etag，客户端拿到后存入其If-none-match；<br>    第二次请求时，服务器需要比对请求中If-none-match的值与Etag是否一致；一致则取缓存；不一致则重新请求<br>-Last-modified &amp; If-modified-since<br>    Last-modified是资源在服务器上的最后修改时间，<br>    第一次请求时，服务器返回资源及其Last-modified，客户端拿到后存入其If-modified-since；<br>    第二次请求时，服务器需要比对请求中If-modified-since的值与Last-modified；Last-modified大于If-modified-sice则资源右更新需要重新请求； 否则取缓存</p>
<pre><code>- 弊端： 1. 以秒计时，如果在秒之内的改变无法检测到
         2. 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改
所以没有etag精确
</code></pre><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>-频繁变动的资源 Cache-Control: no-cache<br>对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
<p>-不常变化的资源 Cache-Control: max-age=31536000<br>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p>
<p>-用户打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。<br>-普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。<br>-强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</p>
<h1 id="36-使用迭代的方式实现-flatten-函数"><a href="#36-使用迭代的方式实现-flatten-函数" class="headerlink" title="36. 使用迭代的方式实现 flatten 函数"></a>36. 使用迭代的方式实现 flatten 函数</h1><p>见11题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> flat = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    arr.map(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(ele))&#123;</span><br><span class="line">            res = res.concat(flat(ele));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.push(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deep 扁平化深度</span></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr, deep</span>) =&gt;</span> &#123;</span><br><span class="line">    deep = deep ? deep : <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">while</span>(deep &amp;&amp; arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">        deep --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="37-为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作"><a href="#37-为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作" class="headerlink" title="37. 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作"></a>37. 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作</h1><h1 id="38-下面代码中-a-在什么情况下会打印-1？"><a href="#38-下面代码中-a-在什么情况下会打印-1？" class="headerlink" title="38. 下面代码中 a 在什么情况下会打印 1？"></a>38. 下面代码中 a 在什么情况下会打印 1？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var a = ?;</span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象隐式转换时，a.valueOf().toString()</span></span><br><span class="line"><span class="comment">// valueOf 优先级高于 toString</span></span><br><span class="line"><span class="comment">// 利用valueOf</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'value'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用toString</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'toString'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据隐式转换的时候，a.valueOf().join().toString()</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="39-BFC"><a href="#39-BFC" class="headerlink" title="39. BFC"></a>39. BFC</h1><p>块级格式化上下文，可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。<br>1.内部box会在垂直方向，一个接一个地放置。<br>2.形成了BFC的区域不会与float box重叠<br>3.计算BFC高度时，浮动元素也参与计算</p>
<h2 id="四种触发BFC的方法："><a href="#四种触发BFC的方法：" class="headerlink" title="四种触发BFC的方法："></a>四种触发BFC的方法：</h2><p>position: absolute/fixed;<br>float不为none, (left/right);<br>display: inline-block/flex/table-cell;<br>overflow不为visible, (hidden/auto/scroll);</p>
<h2 id="作用？使用场景？"><a href="#作用？使用场景？" class="headerlink" title="作用？使用场景？"></a>作用？使用场景？</h2><p>margin合并&amp; margin塌陷（特性1）<br>清除浮动（特性3）<br>左图右文（特性2）</p>
<h1 id="40-在-Vue-中，子组件为何不可以修改父组件传递的-Prop，如果修改了，Vue-是如何监控到属性的修改并给出警告的。"><a href="#40-在-Vue-中，子组件为何不可以修改父组件传递的-Prop，如果修改了，Vue-是如何监控到属性的修改并给出警告的。" class="headerlink" title="40. 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。"></a>40. 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。</h1><h1 id="41-下面代码输出什么"><a href="#41-下面代码输出什么" class="headerlink" title="41. 下面代码输出什么"></a>41. 下面代码输出什么</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2020/02/27/leetcode-collection/" rel="next" title="leetcode-13-20">
                <i class="fa fa-chevron-left"></i> leetcode-13-20
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2020/03/07/interview-alibaba-mayijinfu/" rel="prev" title="interview-alibaba-mayijinfu">
                interview-alibaba-mayijinfu <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JOYCE</p>
              <p class="site-description motion-element" itemprop="description">Do what you want!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">46</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/blog/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><span class="nav-number">1.</span> <span class="nav-text">2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><span class="nav-number">2.</span> <span class="nav-text">4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">2.0.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakSet"><span class="nav-number">2.0.2.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">2.0.3.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakMap"><span class="nav-number">2.0.4.</span> <span class="nav-text">WeakMap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-介绍下深度优先遍历和广度优先遍历，如何实现？"><span class="nav-number">3.</span> <span class="nav-text">5. 介绍下深度优先遍历和广度优先遍历，如何实现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-请分别用深度优先思想和广度优先思想实现一个拷贝函数？"><span class="nav-number">4.</span> <span class="nav-text">6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-ES5-ES6-的继承除了写法以外还有什么区别？"><span class="nav-number">5.</span> <span class="nav-text">7. ES5/ES6 的继承除了写法以外还有什么区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-setTimeout、Promise、Async-Await-的区别"><span class="nav-number">6.</span> <span class="nav-text">8. setTimeout、Promise、Async/Await 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Async-Await-如何通过同步的方式实现异步"><span class="nav-number">7.</span> <span class="nav-text">9. Async/Await 如何通过同步的方式实现异步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-js事件循环（event-loop）-amp-amp-异步"><span class="nav-number">8.</span> <span class="nav-text">10. js事件循环（event loop）&amp;&amp; 异步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-数组扁平化，去重，升序"><span class="nav-number">9.</span> <span class="nav-text">11. 数组扁平化，去重，升序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-JS-异步解决方案的发展历程以及优缺点。"><span class="nav-number">10.</span> <span class="nav-text">12. JS 异步解决方案的发展历程以及优缺点。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><span class="nav-number">11.</span> <span class="nav-text">13. Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-如何实现一个-new"><span class="nav-number">12.</span> <span class="nav-text">14. 如何实现一个 new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-简单讲解一下-http2-的多路复用"><span class="nav-number">13.</span> <span class="nav-text">15. 简单讲解一下 http2 的多路复用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-React-中-setState-什么时候是同步的，什么时候是异步的？"><span class="nav-number">14.</span> <span class="nav-text">18. React 中 setState 什么时候是同步的，什么时候是异步的？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-队列机制"><span class="nav-number">14.1.</span> <span class="nav-text">setState 队列机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState-循环调用风险"><span class="nav-number">14.2.</span> <span class="nav-text">setState 循环调用风险</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#batchingStrategy"><span class="nav-number">14.2.1.</span> <span class="nav-text">batchingStrategy</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-React-setState-笔试题，下面的代码输出什么？"><span class="nav-number">15.</span> <span class="nav-text">19. React setState 笔试题，下面的代码输出什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><span class="nav-number">16.</span> <span class="nav-text">20. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-判断数组的三种方法，比较"><span class="nav-number">17.</span> <span class="nav-text">21. 判断数组的三种方法，比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype-toString-call-arr-‘-Object-Array-’"><span class="nav-number">17.1.</span> <span class="nav-text">Object.prototype.toString.call(arr) === ‘[Object Array]’</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arr-instanceof-Array"><span class="nav-number">17.2.</span> <span class="nav-text">arr instanceof Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arr-constructor-Array"><span class="nav-number">17.3.</span> <span class="nav-text">arr.constructor === Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-isArray-arr"><span class="nav-number">17.4.</span> <span class="nav-text">Array.isArray(arr)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-重排（回流）-amp-重绘"><span class="nav-number">18.</span> <span class="nav-text">22. 重排（回流）&amp;重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何减少重排重绘"><span class="nav-number">18.1.</span> <span class="nav-text">如何减少重排重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#css部分"><span class="nav-number">18.1.1.</span> <span class="nav-text">css部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js部分"><span class="nav-number">18.1.2.</span> <span class="nav-text">js部分</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-观察者模式和订阅-发布模式的区别"><span class="nav-number">19.</span> <span class="nav-text">23. 观察者模式和订阅-发布模式的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-Redux-和-Vuex-的设计思想"><span class="nav-number">20.</span> <span class="nav-text">24. Redux 和 Vuex 的设计思想</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-介绍模块化发展历程"><span class="nav-number">21.</span> <span class="nav-text">26. 介绍模块化发展历程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？。"><span class="nav-number">22.</span> <span class="nav-text">27. 全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><span class="nav-number">23.</span> <span class="nav-text">28. cookie 和 token 都存放在 header 中，为什么不会劫持 token？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-Vue的双向数据绑定-MVVM"><span class="nav-number">24.</span> <span class="nav-text">29. Vue的双向数据绑定 MVVM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-请把俩个数组-A1-A2-B1-B2-C1-C2-D1-D2-和-A-B-C-D-，合并为-A1-A2-A-B1-B2-B-C1-C2-C-D1-D2-D-。"><span class="nav-number">25.</span> <span class="nav-text">30. 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33"><span class="nav-number">26.</span> <span class="nav-text">33.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34"><span class="nav-number">27.</span> <span class="nav-text">34.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-浏览器缓存读取机制"><span class="nav-number">28.</span> <span class="nav-text">35. 浏览器缓存读取机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存位置"><span class="nav-number">28.1.</span> <span class="nav-text">缓存位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-Worker"><span class="nav-number">28.1.1.</span> <span class="nav-text">Service Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-Cache"><span class="nav-number">28.1.2.</span> <span class="nav-text">Memory Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Disk-Cache"><span class="nav-number">28.1.3.</span> <span class="nav-text">Disk Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Push-Cache"><span class="nav-number">28.1.4.</span> <span class="nav-text">Push Cache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存机制"><span class="nav-number">28.2.</span> <span class="nav-text">缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强缓存"><span class="nav-number">28.2.1.</span> <span class="nav-text">强缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协商缓存"><span class="nav-number">28.2.2.</span> <span class="nav-text">协商缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">28.2.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-使用迭代的方式实现-flatten-函数"><span class="nav-number">29.</span> <span class="nav-text">36. 使用迭代的方式实现 flatten 函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作"><span class="nav-number">30.</span> <span class="nav-text">37. 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-下面代码中-a-在什么情况下会打印-1？"><span class="nav-number">31.</span> <span class="nav-text">38. 下面代码中 a 在什么情况下会打印 1？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-BFC"><span class="nav-number">32.</span> <span class="nav-text">39. BFC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#四种触发BFC的方法："><span class="nav-number">32.1.</span> <span class="nav-text">四种触发BFC的方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用？使用场景？"><span class="nav-number">32.2.</span> <span class="nav-text">作用？使用场景？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-在-Vue-中，子组件为何不可以修改父组件传递的-Prop，如果修改了，Vue-是如何监控到属性的修改并给出警告的。"><span class="nav-number">33.</span> <span class="nav-text">40. 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-下面代码输出什么"><span class="nav-number">34.</span> <span class="nav-text">41. 下面代码输出什么</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JOYCE</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/blog/js/src/utils.js?v=7.0.0"></script>

  <script src="/blog/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/blog/js/src/schemes/muse.js?v=7.0.0"></script>



  
  <script src="/blog/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/blog/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/blog/js/src/bootstrap.js?v=7.0.0"></script>


  
  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
